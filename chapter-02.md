# Розділ 2. Основи робоити web-сайтів

## 2.1. Обмін даними між клієнтом і сервером

HTTP – це клієнт-серверний протокол, тобто запити надсилаються якоюсь однією стороною – учасником обміну (user-agent) (або проксі замість нього). Найчастіше в якості учасника виступає веб-браузер, але ним може бути будь-хто, наприклад, робот, що подорожує по Мережі для поповнення та оновлення даних індексації веб-сторінок для пошукових систем.

Кожен запит (англ. request) відправляється серверу, який обробляє його та повертає відповідь (англ. response). Між цими запитами та відповідями зазвичай існують численні посередники, звані проксі, які виконують різні операції та працюють як шлюзи або кеш, наприклад.

### Клієнт (учасник обміну)

Клієнт (user agent або учасник обміну) – це будь-який інструмент або пристрій, що діють від імені користувача. Це завдання переважно виконує веб-браузер; у деяких випадках учасниками виступають програми, які використовуються інженерами та веб-розробниками для налагодження своїх програм.

Браузер завжди є тією сутністю, що створює запит. Сервер зазвичай цього не робить, хоча за багато років існування мережі були вигадані методи, які можуть дозволити виконати запити з боку сервера.

### Веб-сервер

З іншого боку комунікаційного каналу розташований сервер, який обслуговує (англ. serve) користувача, надаючи йому документи на запит. З погляду кінцевого користувача, сервер завжди є якоюсь однією віртуальною машиною, що повністю або частково генерує документ, хоча фактично він може бути групою серверів, між якими балансується навантаження, тобто перерозподіляються запити різних користувачів, або складним програмним забезпеченням, що опитує інші комп'ютери (такі як кешують сервери, сервери баз даних, сервери додатків електронної комерції та інші).

Сервер не обов'язково розташований на одній машині, і навпаки - кілька серверів можуть бути розташовані (хоститися) на одній і тій же машині. Відповідно до версії HTTP/1.1 і маючи Host заголовок, вони навіть можуть ділити ту ж саму IP-адресу.

## 2.2. Протокол HTTP

### Загальні відомості про протокол HTTP

Протокол HTTP призначений для передачі вмісту в Інтернеті. HTTP — це простий протокол, який використовує надійні служби протоколу TCP для передачі вмісту. Завдяки цьому HTTP вважається дуже надійним протоколом обміну вмістом. Також HTTP є одним із найчастіше використовуваних протоколів додатків.

![Нашарування мережевих протоколів](img/02-005.png)

HTTPS – це безпечна версія протоколу HTTP, яка реалізує протокол HTTP за допомогою протоколу TLS для захисту базового під'єднання TCP. За винятком додаткової конфігурації, необхідної для налаштування TLS, використання HTTPS по суті не відрізняється від протоколу HTTP.

У протоколі HTTP є простий механізм запиту вмісту сервера. Доступний стандартний набір команд HTTP, які відправляються клієнтом після успішного встановлення підключення за стандартним TCP-портом 80 (або портом 443 для HTTPS чи іншім портом в деяких окремих випадках). 

Для ідентифікації ресурсів HTTP використовує глобальні URI. На відміну від багатьох інших протоколів, HTTP не зберігає свого стану. Це означає відсутність збереження проміжного стану між парами «запит-відповідь».

### Структура запитів та відповідей HTTP

Основним об'єктом маніпуляції в HTTP є ресурс, на який вказує URI (Uniform Resource Identifier) в запиті клієнта. У найзагальнішому випадку URI виглядає наступним чином:

`protocol://user:password@host:port/path/file?parameters#fragment`

Окремі поля URI мають наступний сенс:

- protocol - прикладний протокол, за допомогою якого отримують доступ до ресурсу;
- user - користувач, від імені якого отримують доступ до ресурсу;
- password - пароль користувача для аутентифікації при доступі до ресурсу;
- host - IP-адреса або ім'я сервера, на якому розташований ресурс;
- port - номер порту, на якому працює сервер, що надає доступ до ресурсу;
- path - шлях до файлу, який містить ресурс;
- file - файл, що містить ресурс;
- parameters - параметри для обробки ресурсом-програмою;
- fragment - точка в файлі, починаючи з якої слід відображати ресурс.

Кожен запит/відповідь складається з наступних частин:

1. початковий рядок 
1. заголовок 1 
1. заголовок 2 ...
1. заголовок N
1. CR LF (порожній рядок) 
1. тіло повідомлення (може бути відсутнім)

Формат початкового рядка (start-line) клієнта і сервера розрізняються. Заголовки бувають чотирьох видів:

- загальні заголовки (general-headers), які можуть бути присутніми як в запиті, так і у відповіді;
- заголовки запитів (request-headers), які можуть бути присутніми тільки в запиті;
- заголовки відповідей (response-headers), які можуть бути присутніми тільки у відповіді;
- заголовки об'єкта (entity-headers), які відносяться до тіла повідомлення і описують його вміст.

Кожен заголовок складається з назви, символу двокрапки ":" і значення.

#### HTTP-запит
Абстрактно приклад запиту можна подати у наступному вигляді:

![Структура HTTP-запиту](img/02-010.png)

Запит може буде виконаний одним з наступних методів:

- **OPTIONS** Повертає методи HTTP, які підтримуються сервером.
- **GET** Запитує вміст вказаного ресурсу. Запитаний ресурс може приймати параметри, вони передаються в рядку URI.
- **HEAD** Аналогічний методу **GET**, за винятком того, що у відповіді сервера відсутнє тіло. Це корисно для витягання метаінформації, заданої в заголовках відповіді, без пересилання всього вмісту.
- **POST** Передає дані користувача заданому ресурсу. При цьому передані дані включаються в Тіло запиту (Request body). На відміну від методу GET, метод POST не вважається ідемпотентним, тобто багаторазове повторення одних і тих же запитів POST може повертати різні результати.
- **PUT** Завантажує вказаний ресурс на сервер.
- **PATCH** Завантажує певну частину ресурсу на сервер.
- **DELETE** Видаляє вказаний ресурс.
- **TRACE** Повертає отриманий запит так, що клієнт може побачити, що проміжні сервери додають або змінюють в запиті.
- **CONNECT** Для використання разом з проксі-серверами, які можуть динамічно перемикатися в тунельний режим SSL.

Приклад реального запиту HTTP виглядає наступним чином:
```
GET /dir/page.php HTTP/1.1
Host: mysite.pp.ua
User-Agent: firefox/5.0 (Linux; Debian 5.0.8; en-US; rv:1.8.1.7) Gecko/20070914 Firefox/2.0.0.7
Connection: close
```
#### HTTP-відповідь
Абстрактно приклад відповіді сервера можна подати у наступному вигляді:

![Структура HTTP-відповіді](img/02-015.png)

Одним із найважливіших параметрів, що повертає сервер у заголовку відповіді є код відповіді. За даним кодом браузер або інша програма, що використовує протокол HTTP, розуміє чи корректно було виконано запит.

Коди відповідей діляться на 5 груп:

1. Інформаційні 100 – 199
2. Успішні 200 - 299
3. Перенаправлення 300 - 399
4. Клієнтські помилки 400 – 499
5. Серверні помилки 500 - 599

Повний перелік кодів відповідей надано у Додатку А.

Найбільш поширені коди відповідей:

- 200 OK — запит виконано успішно.
- 301 Moved Permanently — ресурс переміщено.
- 403 Forbidden — доступ до запитаного ресурсу заборонений.
- 404 Not Found — ресурс не знайдений.
- 500 Internal Server Error — внутрішня проблема роботи web-серверу.
- 503 Service Unavailable — сервіс недоступний.

Приклад реальної HTTP-відповіді 
```
HTTP/1.1 200 OK
Server: Apache
Content-Language: uk
Content-Type: text/html; charset=utf-8
Content-Length: 1234
(пустий рядок)
(далі йде текст html-сторінки)
```

## 2.3. Документ HTML

Результатом інтерпретації HTML-документа браузером є веб-сторінка, яка, на відміну від HTML-документа містить не лише текст, але й зображення, звук, відео, інтерактивні елементи та інше. Процес інтерпретації **(парсинг)** починається перш, ніж веб-сторінка повністю завантажена в браузер. Браузери обробляють HTML-документи послідовно, з самого початку, при цьому обробляючи CSS і співвідносячи таблиці стилів з елементами сторінки.

Отриманий підсумковий документ (може) складатися з різних піддокументів, що є частиною підсумкового документа: наприклад, з окремо отриманого тексту, опис структури документа, зображень, відео-файлів, скриптів та багато іншого.

![Склад документу](img/02-020.png)

Основною одиницею мови HTML є тег. За допомогою тегів описується вся структура HTML-документа. Теги оформляються кутовими дужками <ім'я тегу>, між якими прописується ім'я тегу.

Практично всі теги мають **атрибути** (глобальні, що застосовуються для всіх html-елементів, і власні), які вказуються у форматі **параметр = "значення"**. Атрибути дозволяють змінювати властивості елемента, для якого вони задані. Атрибути прописуються в початковому тезі елемента.

Атрибути **class** і **id** застосовні до всіх HTML-елементів. Кожному конкретному елементу можна привласнити кілька значень class і тільки одне значення id. Множинні значення class записуються через пробіл, наприклад, <div class = "nav top">

Значення class і id повинні складатися тільки з букв, цифр, дефісів і нижніх підкреслень і повинні починатися тільки з літер.

Більшість тегів - парні, вони складаються з початкового і кінцевого тегів. Початковий тег показує, де починається елемент, кінцевий - де закінчується. Закриваючий тег утворюється шляхом додавання слешу / перед ім'ям тега: <ім'я тега> ... . Між початковим і кінцевим тегами знаходиться вміст тега - контент.

Одиночні теги не можуть зберігати в собі вмісту безпосередньо, він прописується як значення атрибута, наприклад, тег <input type = "button" value = "Кнопка">

### Структура HTML-документа

HTML слідує правилам, які містяться у файлі оголошення типу документа (Document Type Definition, або DTD). DTD являє собою XML-документ, що визначає, які теги, атрибути та їх значення дійсні для конкретного типу HTML. Для кожної версії HTML є свій DTD.

DOCTYPE відповідає за коректне відображення веб-сторінки браузером. DOCTYPE визначає не тільки версію HTML (наприклад, html), але і відповідний DTD-файл в Інтернеті.

```html
<!DOCTYPE html> <! - Оголошення формату документа ->
<html>
<head>  <!- Технічна інформація про документ ->
<meta charset = "UTF-8"> <! - Визначаємо кодування символів документа ->
<title> ... </title> <! - Задаємо заголовок документа ->
<link rel = "stylesheet" type = "text / css" href = "style.css"> 
<! - Підключаємо зовнішню таблицю стилів ->
<script src = "script.js"> </script> <! - Підключаємо сценарії ->
</head>
<body> <! - Основна частина документа ->
</body>
</html>
```	

Елементи, що знаходяться всередині тега **DOM (document object model)** . При цьому елемент є кореневим елементом.

Щоб розібратися у взаємодії елементів веб-сторінки, необхідно розглянути так звані "родинні стосунки" між елементами. Відносини між множинними вкладеними елементами підрозділяються на батьківські, дочірні та сестринські.

**Предок** - елемент, який містить в собі інші елементи. Gредком для всіх елементів є `<html>`. У той же час елемент `<body>` є предком для всіх містяться в ньому тегів: `<h1>`,`<p>`, `<span>`, `<nav>`і т.д.

**Нащадок** - елемент, розташований всередині одного або більше типів елементів. Наприклад, `<body>` є нащадком `<html>`, а елемент `<p>` є нащадком одночасно для `<body>` і `<html>`.

**Батьківський елемент** - елемент, пов'язаний з іншими елементами нижчого рівня, і що знаходиться на дереві вище їх. На рис. 1 `<html>` є батьківським тільки для `<head>` і `<body>`. Тег `<p>` є батьківським тільки для `<span>`.

**Дочірній елемент** - елемент, безпосередньо підлеглий іншому елементу більш високого рівня. На рис. 1 тільки елементи `<h1>`, `<h2>`, `<p>` і `<nav>` є дочірніми по відношенню до `<body>`.

**Сестринський елемент** - елемент, що має загальний батьківський елемент з даним, так звані елементи одного рівня. На рис. 1 `<head>` і `<body>` - елементи одного рівня, так само як і елементи `<h1>`, `<h2>` і `<p>` є між собою сестринськими.

